import { __awaiter } from "tslib";
import { WebPlugin } from '@capacitor/core';
import { DatabaseSQLiteHelper } from './electron-utils/DatabaseSQLiteHelper';
import { isJsonSQLite } from './electron-utils/JsonUtils';
import { UtilsSQLite } from './electron-utils/UtilsSQLite';
const { remote } = require('electron');
export class CapacitorSQLiteElectronWeb extends WebPlugin {
    constructor() {
        super({
            name: 'CapacitorSQLite',
            platforms: ['electron'],
        });
        this.NodeFs = null;
        this.RemoteRef = null;
        this.versionUpgrades = {};
        console.log('CapacitorSQLite Electron');
        this.RemoteRef = remote;
        this.NodeFs = require('fs');
    }
    echo(options) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('ECHO in CapacitorSQLiteElectronWeb ', options);
            console.log(this.RemoteRef);
            return options;
        });
    }
    open(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof options.database === 'undefined') {
                return Promise.reject({
                    result: false,
                    message: 'Must provide a database name',
                });
            }
            const dbName = options.database;
            const dbVersion = (_a = options.version) !== null && _a !== void 0 ? _a : 1;
            /*
                    let encrypted: boolean = options.encrypted ? options.encrypted : false;
                    let inMode: string = "no-encryption";
                    let secretKey: string = "";
                    let newsecretKey: string = "";
                    */
            console.log('---> in Open this.versionUpgrades ' + this.versionUpgrades);
            this.mDb = new DatabaseSQLiteHelper(`${dbName}SQLite.db`, dbVersion, this.versionUpgrades /*,encrypted,inMode,secretKey,newsecretKey*/);
            yield this.mDb.setup();
            if (!this.mDb.isOpen) {
                return Promise.resolve({
                    result: false,
                    message: `Open command failed: Database ${dbName}SQLite.db not opened`,
                });
            }
            else {
                return Promise.resolve({ result: true });
            }
        });
    }
    close(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof options.database === 'undefined') {
                return Promise.reject({
                    result: false,
                    message: 'Close command failed: Must provide a database name',
                });
            }
            const dbName = options.database;
            const ret = yield this.mDb.close(`${dbName}SQLite.db`);
            if (!ret) {
                return Promise.reject({ status: false, message: 'Close command failed' });
            }
            return Promise.resolve({ result: true });
        });
    }
    execute(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const retRes = { changes: -1 };
            if (typeof options.statements === 'undefined') {
                return Promise.reject({
                    changes: retRes,
                    message: 'Execute command failed : Must provide raw SQL statements',
                });
            }
            const statements = options.statements;
            const ret = yield this.mDb.exec(statements);
            return Promise.resolve({ changes: ret });
        });
    }
    executeSet(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const retRes = { changes: -1 };
            if (typeof options.set === 'undefined') {
                return Promise.reject({
                    changes: retRes,
                    message: 'ExecuteSet command failed : Must provide a set of SQL statements',
                });
            }
            const setOfStatements = options.set;
            if (setOfStatements.length === 0) {
                return Promise.reject({
                    changes: retRes,
                    message: 'ExecuteSet command failed : Must provide a non-empty set of SQL statements',
                });
            }
            for (let i = 0; i < setOfStatements.length; i++) {
                if (!('statement' in setOfStatements[i]) ||
                    !('values' in setOfStatements[i])) {
                    return Promise.reject({
                        changes: retRes,
                        message: 'ExecuteSet command failed : Must provide a set as Array of {statement,values}',
                    });
                }
            }
            const ret = yield this.mDb.execSet(setOfStatements);
            return Promise.resolve({ changes: ret });
        });
    }
    run(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const retRes = { changes: -1 };
            if (typeof options.statement === 'undefined') {
                return Promise.reject({
                    changes: retRes,
                    message: 'Run command failed : Must provide a SQL statement',
                });
            }
            if (typeof options.values === 'undefined') {
                return Promise.reject({
                    changes: retRes,
                    message: 'Run command failed : Values should be an Array of values',
                });
            }
            const statement = options.statement;
            const values = options.values;
            let ret;
            if (values.length > 0) {
                ret = yield this.mDb.run(statement, values);
            }
            else {
                ret = yield this.mDb.run(statement, []);
            }
            return Promise.resolve({ changes: ret });
        });
    }
    query(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof options.statement === 'undefined') {
                return Promise.reject({
                    values: [],
                    message: 'Query command failed : Must provide a SQL statement',
                });
            }
            if (typeof options.values === 'undefined') {
                return Promise.reject({
                    values: [],
                    message: 'Query command failed : Values should be an Array of values',
                });
            }
            const statement = options.statement;
            const values = options.values;
            let ret;
            if (values.length > 0) {
                ret = yield this.mDb.query(statement, values);
            }
            else {
                ret = yield this.mDb.query(statement, []);
            }
            return Promise.resolve({ values: ret });
        });
    }
    isDBExists(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let dbName = options.database;
            if (dbName == null) {
                return Promise.reject({
                    result: false,
                    message: 'Must provide a Database Name',
                });
            }
            dbName = `${options.database}SQLite.db`;
            const utils = new UtilsSQLite();
            const dbPath = utils.getDBPath(dbName);
            let message = '';
            let ret = false;
            try {
                if (this.NodeFs.existsSync(dbPath)) {
                    //file exists
                    ret = true;
                }
            }
            catch (err) {
                ret = false;
                message = err.message;
            }
            finally {
                if (ret) {
                    return Promise.resolve({ result: ret });
                }
                else {
                    return Promise.resolve({ result: ret, message: message });
                }
            }
        });
    }
    deleteDatabase(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let dbName = options.database;
            if (dbName == null) {
                return Promise.reject({
                    result: false,
                    message: 'Must provide a Database Name',
                });
            }
            dbName = `${options.database}SQLite.db`;
            if (typeof this.mDb === 'undefined' || this.mDb === null) {
                return Promise.reject({
                    result: false,
                    message: 'The database is not opened',
                });
            }
            const ret = yield this.mDb.deleteDB(dbName);
            return Promise.resolve({ result: ret });
        });
    }
    isJsonValid(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const jsonStrObj = options.jsonstring;
            if (typeof jsonStrObj != 'string' ||
                jsonStrObj == null ||
                jsonStrObj.length === 0) {
                return Promise.reject({
                    result: false,
                    message: 'Must provide a json object',
                });
            }
            const jsonObj = JSON.parse(jsonStrObj);
            const isValid = isJsonSQLite(jsonObj);
            if (!isValid) {
                return Promise.reject({
                    result: false,
                    message: 'Stringify Json Object not Valid',
                });
            }
            else {
                return Promise.resolve({ result: true });
            }
        });
    }
    importFromJson(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const retRes = { changes: -1 };
            const jsonStrObj = options.jsonstring;
            if (typeof jsonStrObj != 'string' ||
                jsonStrObj == null ||
                jsonStrObj.length === 0) {
                return Promise.reject({
                    changes: retRes,
                    message: 'Must provide a json object',
                });
            }
            const jsonObj = JSON.parse(jsonStrObj);
            const isValid = isJsonSQLite(jsonObj);
            if (!isValid)
                return Promise.reject({
                    changes: retRes,
                    message: 'Must provide a jsonSQLite object',
                });
            const dbName = `${jsonObj.database}SQLite.db`;
            const dbVersion = (_a = jsonObj.version) !== null && _a !== void 0 ? _a : 1;
            this.mDb = new DatabaseSQLiteHelper(dbName, dbVersion, {});
            yield this.mDb.setup();
            const ret = yield this.mDb.importJson(jsonObj);
            this.mDb.close(dbName);
            //      this.mDb = null;
            return Promise.resolve({ changes: ret });
        });
    }
    exportToJson(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const retRes = {};
            if (typeof options.jsonexportmode === 'undefined') {
                return Promise.reject({
                    export: retRes,
                    message: 'Must provide a json export mode',
                });
            }
            if (options.jsonexportmode != 'full' &&
                options.jsonexportmode != 'partial') {
                return Promise.reject({
                    export: retRes,
                    message: "Json export mode should be 'full' or 'partial'",
                });
            }
            const exportMode = options.jsonexportmode;
            const ret = yield this.mDb.exportJson(exportMode);
            return Promise.resolve({ export: ret });
        });
    }
    createSyncTable() {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this.mDb.createSyncTable();
            return Promise.resolve({ changes: ret });
        });
    }
    setSyncDate(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof options.syncdate === 'undefined' ||
                typeof options.syncdate != 'string') {
                return Promise.reject({
                    result: false,
                    message: 'Must provide a synchronization date',
                });
            }
            const syncDate = options.syncdate;
            const ret = yield this.mDb.setSyncDate(syncDate);
            return Promise.resolve({ result: ret });
        });
    }
    addUpgradeStatement(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof options.database === 'undefined' ||
                typeof options.database != 'string') {
                return Promise.reject({
                    result: false,
                    message: 'Must provide a database name',
                });
            }
            if (typeof options.upgrade[0] === 'undefined') {
                return Promise.reject({
                    result: false,
                    message: 'Must provide an upgrade Object',
                });
            }
            const upgrade = options.upgrade[0];
            const keys = Object.keys(upgrade);
            if (!keys.includes('fromVersion') ||
                !keys.includes('toVersion') ||
                !keys.includes('statement')) {
                return Promise.reject({
                    result: false,
                    message: 'Must provide an upgrade capSQLiteVersionUpgrade Object',
                });
            }
            const fullDBName = `${options.database}SQLite.db`;
            if (!this.versionUpgrades[fullDBName]) {
                this.versionUpgrades[fullDBName] = {};
            }
            this.versionUpgrades[fullDBName][upgrade.fromVersion] = {
                fromVersion: upgrade.fromVersion,
                toVersion: upgrade.toVersion,
                statement: upgrade.statement,
            };
            if (upgrade.set)
                this.versionUpgrades[fullDBName][upgrade.fromVersion]['set'] =
                    upgrade.set;
            return Promise.resolve({ result: true });
        });
    }
}
const CapacitorSQLite = new CapacitorSQLiteElectronWeb();
export { CapacitorSQLite };
import { registerWebPlugin } from '@capacitor/core';
registerWebPlugin(CapacitorSQLite);
//# sourceMappingURL=plugin.js.map