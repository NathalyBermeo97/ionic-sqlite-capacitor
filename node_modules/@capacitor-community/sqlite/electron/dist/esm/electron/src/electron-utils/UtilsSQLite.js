export class UtilsSQLite {
    constructor() {
        this.pathDB = 'Databases';
        this.Path = null;
        this.NodeFs = null;
        this.RemoteRef = null;
        this.Os = null;
        this.SQLite3 = null;
        this.AppName = null;
        this.HomeDir = null;
        this.Path = require('path');
        this.NodeFs = require('fs');
        this.Os = require('os');
        this.SQLite3 = require('sqlite3');
        this.HomeDir = this.Os.homedir();
        /**
         * !!! in case you want your databases to be stored in YourApplication/Electron/
         * comment the below line
         */
        this.AppName = require('../../package.json').name;
    }
    connection(dbName, readOnly /*,key?:string*/) {
        const flags = readOnly
            ? this.SQLite3.OPEN_READONLY
            : this.SQLite3.OPEN_CREATE | this.SQLite3.OPEN_READWRITE;
        // get the path for the database
        const dbPath = this.getDBPath(dbName);
        let dbOpen = null;
        if (dbPath.length > 0) {
            try {
                dbOpen = new this.SQLite3.Database(dbPath, flags);
            }
            catch (e) {
                console.log('Error: in UtilsSQLite.connection ', e);
                dbOpen = null;
            }
            finally {
                if (dbOpen != null) {
                    const statements = 'PRAGMA foreign_keys = ON;';
                    dbOpen.serialize(() => {
                        dbOpen.exec(statements, (err) => {
                            if (err) {
                                console.log(`exec: Error PRAGMA foreign_keys failed : ${err.message}`);
                                dbOpen = null;
                            }
                        });
                    });
                }
                return dbOpen;
            }
        }
    }
    getWritableDatabase(dbName /*, secret: string*/) {
        const db = this.connection(dbName, false /*,secret*/);
        return db;
    }
    getReadableDatabase(dbName /*, secret: string*/) {
        const db = this.connection(dbName, true /*,secret*/);
        return db;
    }
    getDBPath(dbName) {
        let retPath = '';
        const dbFolder = this.pathDB;
        if (this.AppName == null) {
            let sep = '/';
            const idx = __dirname.indexOf('\\');
            if (idx != -1)
                sep = '\\';
            const dir = __dirname.substring(0, __dirname.lastIndexOf(sep) + 1);
            retPath = this.Path.join(dir, dbFolder, dbName);
            const retB = this._createFolderIfNotExists(this.Path.join(dir, dbFolder));
            if (!retB)
                retPath = '';
        }
        else {
            retPath = this.Path.join(this.HomeDir, dbFolder, this.AppName, dbName);
            let retB = this._createFolderIfNotExists(this.Path.join(this.HomeDir, dbFolder));
            if (retB) {
                retB = this._createFolderIfNotExists(this.Path.join(this.HomeDir, dbFolder, this.AppName));
                if (!retB)
                    retPath = '';
            }
            else {
                retPath = '';
            }
        }
        return retPath;
    }
    _createFolderIfNotExists(folder) {
        let ret;
        try {
            if (!this.NodeFs.existsSync(folder)) {
                this._mkdirSyncRecursive(folder);
            }
            ret = true;
        }
        catch (e) {
            console.log('Error: in getDBPath', e);
            ret = false;
        }
        return ret;
    }
    _mkdirSyncRecursive(directory) {
        var path = directory.replace(/\/$/, '').split('/');
        for (var i = 1; i <= path.length; i++) {
            var segment = path.slice(0, i).join('/');
            segment.length > 0 && !this.NodeFs.existsSync(segment)
                ? this.NodeFs.mkdirSync(segment)
                : null;
        }
        return;
    }
}
//# sourceMappingURL=UtilsSQLite.js.map